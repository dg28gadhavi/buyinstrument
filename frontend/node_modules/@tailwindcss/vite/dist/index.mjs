import{compile as x,env as h,normalizePath as P}from"@tailwindcss/node";import{clearRequireCache as U}from"@tailwindcss/node/require-cache";import{Scanner as B}from"@tailwindcss/oxide";import{Features as D,transform as G}from"lightningcss";import F from"node:fs/promises";import v from"node:path";import{sveltePreprocess as M}from"svelte-preprocess";var V=/[?&](raw|url)\b/;function q(){let s=[],t=null,l=!1,a=!1,c=new y(()=>new Set),p=new B({}),r=new y(e=>new R(e,()=>c,t.base));function f(e,i,o,u){let n=!1;for(let d of p.scanFiles([{content:i,extension:o}]))n=!0,c.get(e).add(d);n&&m(u)}function m(e){for(let i of s){let o=[];for(let[u,n]of r.entries()){let d=i.moduleGraph.getModuleById(u);if(!d){if(n.builtBeforeTransform)continue;e||r.delete(u);continue}r.get(u).requiresRebuild=!1,i.moduleGraph.invalidateModule(d),o.push({type:`${d.type}-update`,path:d.url,acceptedPath:d.url,timestamp:Date.now()})}o.length>0&&i.hot.send({type:"update",updates:o})}}async function g(e,i){let o=e.lastContent,u=await e.generate(o,i);if(u===!1)return;h.DEBUG&&console.time("[@tailwindcss/vite] Optimize CSS");let n=A(u,{minify:a});return h.DEBUG&&console.timeEnd("[@tailwindcss/vite] Optimize CSS"),n}async function w(e,i,o){let u={...e,getCombinedSourcemap:()=>{throw new Error("getCombinedSourcemap not implemented")}};for(let n of t.plugins){if(!n.transform||n.name.startsWith("@tailwindcss/"))continue;if(n.name.startsWith("vite:")&&n.name!=="vite:css"&&n.name!=="vite:css-post"&&n.name!=="vite:vue")continue;if(n.name==="ssr-styles")continue;let d="handler"in n.transform?n.transform.handler:n.transform;try{let b=await d.call(u,o,i);if(!b)continue;typeof b=="string"?o=b:b.code&&(o=b.code)}catch{console.error(`Error running ${n.name} on Tailwind CSS output. Skipping.`)}}return o}return[W(r),{name:"@tailwindcss/vite:scan",enforce:"pre",configureServer(e){s.push(e)},async configResolved(e){t=e,a=t.build.cssMinify!==!1,l=t.build.ssr!==!1&&t.build.ssr!==void 0},transformIndexHtml(e,{path:i}){f(i,e,"html",l)},transform(e,i,o){let u=E(i);C(i)||f(i,e,u,o?.ssr??!1)}},{name:"@tailwindcss/vite:generate:serve",apply:"serve",enforce:"pre",async transform(e,i,o){if(!C(i))return;let u=r.get(i);if(u.builtBeforeTransform&&(u.builtBeforeTransform.forEach(d=>this.addWatchFile(d)),u.builtBeforeTransform=void 0),S(i))return e;o?.ssr||await Promise.all(s.map(d=>d.waitForRequestsIdle(i)));let n=await u.generate(e,d=>this.addWatchFile(d));return n?{code:n}:(r.delete(i),e)}},{name:"@tailwindcss/vite:generate:build",apply:"build",enforce:"pre",async transform(e,i){if(!C(i))return;let o=r.get(i);if(o.builtBeforeTransform&&(o.builtBeforeTransform.forEach(n=>this.addWatchFile(n)),o.builtBeforeTransform=void 0),S(i))return e;let u=await o.generate(e,n=>this.addWatchFile(n));return u?{code:u}:(r.delete(i),e)},async renderStart(){for(let[e,i]of r.entries()){if(S(e))continue;let o=await g(i,()=>{});if(!o){r.delete(e);continue}await w(this,e,o)}}}]}function E(s){let[t]=s.split("?",2);return v.extname(t).slice(1)}function C(s){if(s.includes("/.vite/"))return;let t=E(s);return(t==="css"||t==="vue"&&s.includes("&lang.css")||t==="astro"&&s.includes("&lang.css")||S(s))&&!V.test(s)}function S(s){return E(s)==="svelte"&&s.includes("&lang.css")}function A(s,{file:t="input.css",minify:l=!1}={}){function a(c){return G({filename:t,code:c,minify:l,sourceMap:!1,drafts:{customMedia:!0},nonStandard:{deepSelectorCombinator:!0},include:D.Nesting,exclude:D.LogicalProperties,targets:{safari:16<<16|1024},errorRecovery:!0}).code}return a(a(Buffer.from(s))).toString()}function T(s){return v.resolve(s.replace(/\?.*$/,""))}var y=class extends Map{constructor(l){super();this.factory=l}get(l){let a=super.get(l);return a===void 0&&(a=this.factory(l,this),this.set(l,a)),a}},R=class{constructor(t,l,a){this.id=t;this.getSharedCandidates=l;this.base=a}lastContent="";builtBeforeTransform;compiler;requiresRebuild=!0;scanner;candidates=new Set;dependencies=new Set;basePath=null;overwriteCandidates=null;async generate(t,l){this.lastContent=t;let a=T(this.id),c=v.dirname(v.resolve(a));if(!this.compiler||!this.scanner||this.requiresRebuild){U(Array.from(this.dependencies)),this.dependencies=new Set([T(a)]),h.DEBUG&&console.time("[@tailwindcss/vite] Setup compiler"),this.compiler=await x(t,{base:c,shouldRewriteUrls:!0,onDependency:f=>{l(f),this.dependencies.add(f)}}),h.DEBUG&&console.timeEnd("[@tailwindcss/vite] Setup compiler");let r=(this.compiler.root==="none"?[]:this.compiler.root===null?[]:[this.compiler.root]).concat(this.compiler.globs);this.scanner=new B({sources:r})}if(!this.overwriteCandidates){h.DEBUG&&console.time("[@tailwindcss/vite] Scan for candidates");for(let r of this.scanner.scan())this.candidates.add(r);h.DEBUG&&console.timeEnd("[@tailwindcss/vite] Scan for candidates")}for(let r of this.scanner.files)l(r);for(let r of this.scanner.globs){if(r.pattern[0]==="!")continue;let f=v.relative(this.base,r.base);f[0]!=="."&&(f="./"+f),f=P(f),l(v.posix.join(f,r.pattern));let m=this.compiler.root;if(m!=="none"&&m!==null){let g=P(v.resolve(m.base,m.pattern));if(!await F.stat(g).then(e=>e.isDirectory(),()=>!1))throw new Error(`The path given to \`source(\u2026)\` must be a directory but got \`source(${g})\` instead.`);this.basePath=g}else m===null&&(this.basePath=null)}this.requiresRebuild=!0,h.DEBUG&&console.time("[@tailwindcss/vite] Build CSS");let p=this.compiler.build(this.overwriteCandidates?this.overwriteCandidates:[...this.sharedCandidates(),...this.candidates]);return h.DEBUG&&console.timeEnd("[@tailwindcss/vite] Build CSS"),p}sharedCandidates(){if(!this.compiler)return new Set;if(this.compiler.root==="none")return new Set;let t=/^[A-Z]:/,l=c=>this.basePath===null||c.startsWith(this.basePath)?!0:t.test(c)?!1:!c.startsWith("/"),a=new Set;for(let[c,p]of this.getSharedCandidates())if(l(c))for(let r of p)a.add(r);return a}};function W(s){let t=M();return{name:"@tailwindcss/svelte",api:{sveltePreprocess:{markup:t.markup,script:t.script,async style({content:l,filename:a,markup:c,...p}){if(!a)return t.style?.({...p,content:l,filename:a,markup:c});let r=a+"?svelte&type=style&lang.css",f=s.get(r);f.requiresRebuild=!0,f.builtBeforeTransform=[];let m=new B({});f.overwriteCandidates=m.scanFiles([{content:c,file:a,extension:"svelte"}]);let g=await f.generate(l,w=>f?.builtBeforeTransform?.push(w));return g?t.style?.({...p,content:g,filename:a,markup:c}):(s.delete(r),t.style?.({...p,content:l,filename:a,markup:c}))}}}}}export{q as default};
